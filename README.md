# Градационные алгоритмы обработки  изображений

Тема: Градационные алгоритмы обработки  изображений.
Цель работы: изучение градационных алгоритмов обработки  изображений и получение практических навыков по их программной реализации. 

1. Краткие теоретические сведения
В настоящее время цифровая обработка изображений широко используется при решении ряда практических задач. Примерами служат обработка и анализ данных дистанционного зондирования Земли со спутников, методы неразрушающих исследований и контроля в промышленности, разработка «органов зрения» роботов и современных медицинских систем диагностики (рентгенография, машинная томография, эндоскопия и т.д.). Для успешного решения задач поиска и идентификации объектов, определения различного рода их количественных характеристик необходимо, чтобы первичные изображения характеризовались высоким визуальным качеством, которое теряется из-за неудовлетворительных условий получения изображений, несовершенства систем передачи видеоинформации и ее отображения, влияния помех и т.п. 
Поэтому актуальной является задача преобразования изображений с целью улучшения их визуального качества и повышения информативности.  Все основное множество методов, которые решают эту задачу, делится на  методы обработки в частотной и пространственной областях. Термин  пространственная область относиться к плоскости изображения как таковой, и данная категория объединяет подходы, основанные на прямом манипулировании пикселями изображения. К преимуществам методов обработки изображений в пространственной области относится возможность быстрой обработки в масштабе реального времени телевизионного видеосигнала, а к недостаткам - ограниченность функциональных возможностей и недостаточная эффективность. Хотя способы обработки изображений в частотной области и достаточно развиты, но требуют значительных вычислительных затрат и для решения практических задач применяются реже.
В общем виде процессы пространственной обработки изображений описываются выражением:
,
где - элементы входного изображения F; 
- элементы обработанного изображения G; 
T- оператор преобразования входного изображения в окрестности точки с координатами ( ij ). 
Под окрестностью вокруг точки понимают квадратную или прямоугольную область изображения, которая центрирована в точке с координатами ( ij ). Простейшая форма оператора достигается в случае, когда  окрестность имеет размеры 1×1. При этом значение g зависит только от значения f в точке ( ij ) и оператор T становится функцией градационного преобразования (функцией преобразования интенсивностей или функцией отображения). На основе градационных (поэлементных) преобразований  строятся хотя и простые, но достаточно эффективные преобразования изображений (получение негативного изображения, логарифмическое и степенное преобразования и др.). Увеличение значений окрестности приводит к значительно большей гибкости при обработке изображений. При этом используется маска (апертура, окно, ядро, окрестность), которая представляет собой двумерный массив заданного размера, чаще всего размером 3×3. Такие методы называют обработкой или фильтрацией на основе маски. 
Преобразование цветного изображения в полутоновое заключается в получении яркости каждой точки по формуле: 
Y=0.3R+0.59G+0.11B
и последующем копировании на все три канала полученной величины (R=B=G=Y). Где R,G,B – значение красного, зеленого и синего цветов в обрабатываемой точке. 
Бинаризация – это преобразование изображения к одноцветному (монохромному или бинарному). Пусть  – полутоновое изображение, t – порог и ,  – два бинарных значения (для бинарного черно-белого , ). Результат порогового разделения – бинарное изображение , полученное следующим образом:

Как видно, основной задачей является выбор значения t с помощью некоторого критерия. Это значение может выбираться как одинаковым для всего изображения, так и различным для различных его частей. Если значения объектов и фона режима достаточно однородны по всему изображению, то может использоваться одно пороговое значение для всего изображения. Использование единственного значения порога для всех пикселей изображения называется глобальным пороговым разделением.
Однако для многих сканированных изображений глобальное пороговое значение не может использоваться из-за неоднородностей внутри областей фона и объектов. Для этого типа изображения требуются различные пороговые значения для различных частей изображения. Использование различных пороговых значений для различных частей изображения называется адаптивным или локальным пороговым разделением.

2. Виды градационных преобразований

1. Преобразование изображения в негатив. Для изображения с диапазоном яркостей [ 0,.l.,L 1] выполняется согласно выражению: 

Такой переворот уровней яркостей цифровых изображений создает эффект фотографического негатива. Преобразование используется для усиления белых или серых деталей на фоне темных областей изображения, особенно когда темные области имеют преобладающие размеры и широко применяется при обработке цифровых медицинских снимков. 
2. Логарифмическое преобразование:

где c – константа, f  0, ..., L  1. 
Использование логарифма позволяет узкий диапазон малых значений яркости преобразовать в более широкий диапазон выходных значений. Для больших значений входного сигнала верно противоположное утверждение. Такой тип преобразования используется для растяжения диапазона значений темных пикселей на изображении с одновременным сжатием диапазона значений ярких пикселей. При использовании обратного логарифмического преобразования происходит растяжение диапазона значений ярких пикселей на изображении с одновременным сжатием диапазона значений темных пикселей. Логарифмическая функция имеет важную особенность – позволяет сжимать динамический диапазон изображений, имеющих большие вариации в значениях пикселей. Классическим примером большого динамического диапазона пикселей является спектр Фурье изображения, поэтому для отображения спектра используется логарифмическое преобразование, позволяющее отобразить большее количество видимых спектральных составляющих.
3. Степенные преобразования описываются выражением:
,
где c,  – положительные константы. 
Следует отметить, что уравнение приводит к тождественному преобразованию при c    1. В отличие от логарифмического преобразования, здесь возможно целое семейство преобразований, получаемых изменением величины . Преобразования со значениями   1, дают прямо противоположный эффект по сравнению с преобразованиями, которые получены при   1. Следует отметить, что амплитудная характеристика многих устройств, используемых для ввода, печати или визуализации изображений соответствует степенному закону. Процедура, используемая для коррекции такой степенной характеристики называется гамма-коррекцией (отсюда и обозначение показателя степени). Например ЭЛТ мониторы имеют степенную зависимость яркости от напряжения с показателем степени в диапазоне от 1,8 до 2,5, т.е. изображения на мониторе будут темнее, чем они ест на самом деле. Некоторые компьютерные системы имеют встроенную частичную гамма-коррек-цию. Кроме этого гамма-коррекция используется для универсального управления контрастом, в частности при обработке медицинских изображений.
В результате применения логарифмического или степенного преобразования изменяется лишь яркость изображения. 




3. Задания к лабораторной работе

1. Обязательные задания для всех вариантов 
1.1 Загрузка и сохранение изображения заданного формата. Тип формата графического файла обрабатываемого изображения определяется по следующим вариантам:
0. 	BMP
1.	JPEG
2.	PNG
1.2 Преобразование цветного изображения в полутоновое
1.3 Преобразование полутонового изображения в бинарное
2. Градационное преобразование определяется по следующим вариантам:
0. 	Преобразование изображения в негатив
1.	Логарифмическое преобразование
2.	Степенное преобразование   1
3.	Степенное преобразование   1
3. Обработка выданных преподавателем изображений и составление отчета по п.1- 2 

4. Обработка изображений на языке программирования C++ Builder

Отображение и хранение графической информации
В С++ Builder отображение графической информации можно выполнить с помощью компонента TImage, который находится во вкладке Additional палитры компонентов. Программа, приведенная в листинге 1, по щелчку на  соответствующей кнопке загружает в компонент изображение, выбранное в  диалоговом окне Open. Затем она отображает в нескольких полях редактирования основную информацию об этом изображении. В данном проекте для имен компонентов используется значения, действующие по умолчанию.

Листинг 1 Загрузка изображения и получение информации о нем

void __fastcall TForm1::Button1Click(TObject *Sender) 
{ 
    OpenDialog1->Filter = "Bmp files (*.bmp)|*.BMP" ; 
    if (OpenDialog1->Execute()) 
   { 
       Image1->Picture->Bitmap->LoadFromFile(OpenDialog1->FileName); 
       Edit1->Text = OpenDialog1->FileName; 
       Edit2->Text = Image1->Width; 
       Edit3->Text = Image1->Height; 
       Edit4->Text = Image1->Picture->Bitmap->PixelFormat; 
    }
} 
Первый оператор отображает диалоговое окно Open в виде объекта OpenDialog1 типа TOpenDialog, с использованием фильтра для BMP-файлов.  Если это диалоговое окно возвращает значение true, значит, пользователь  выбрал файл, который затем загружается в “растровый” компонент Image1. Для получения информации нужно получить доступ к свойствам компонента Image1. В частности, PixelFormat – это свойство перечислимого типа, определенного следующим образом в заголовочном файле graphics.hpp C++ Builder.
enum TPixelFormat {pfDevice, pf1bit, pf4bit, pf8bit, pf15bit, pf16bit, 
                                             pf24bit, pf32bit, pfCustom};
Следовательно, 24-разрядному цветному изображению будет соответствовать числовое значение 6, которое содержится в свойстве PixelFormat. Для 8-разрядного изображения в оттенках серого свойство PixelFormat имеет значение 3. 
Для сохранения изображения, которое находиться в растровом компоненте Image1, можно использовать оператор, представленный ниже:
if (SaveDialog1->Execute()) 
Image1->Picture->Bitmap->SaveToFile(SaveDialog1->FileName); 
Для хранения графических объектов, содержащихся в битовых матрицах, в C++ Builder определен класс TBitmap. Таким образом, запомнить содержимое графического изображения и затем восстанавливать его, если оно будет испорчено или изменено пользователем можно с использованием объекта типа TBitmap. Код, решающий эту задачу, может иметь вид:
// Объявление и создание объекта Bitmap
Graphics:: TBitmap *Bitmap = new Graphics:: TBitmap(); 
...
void _fastcall TForm1::FormDestroy (TObject *Sender) 
// Уничтожение Bitmap и освобождение памяти
{ 
    Bitmap->Free(); 
} 
//------------------------------------------------------------------------------- 
void _fastcall TForm1::MOpenClick (TObject *Sender) 
// Загрузка изображения из файла в Bitmap и Image1
{ 
    if (OpenPictureDialog1->Execute()) 
   { 
       Bitmap->LoadFromFile (OpenDialog1->FileName); 
       Image1->Picture->Assign(Bitmap); 
   } 
} 
//------------------------------------------------------------------------------- 
void _fastcall TForm1::MSaveClick (TObject *Sender) 
// Сохранение изображения из Image1 в Bitmap
{ 
    Bitmap-> Assign(Image1->Picture); 
} 
//------------------------------------------------------------------------------- 
void _fastcall TForm1::MRestoreClick (TObject *Sender) 
// Восстановление изображения в Image1 из Bitmap
{ 
    Image1->Picture-> Assign(Bitmap);
} 
В этом коде сначала объявляется переменная Bitmap типа Tbitmap и создается соответствующий объект. Если создан объект Bitmap, то необходимо его уничтожить при окончании работы и освободить от него память. Автоматически это не делается. Поэтому надо освобождать память, например, в обработчике события формы OnDestroy (процедура FormDestroy) методом Free:
Bitmap ->Free();
В процедуре MopenClick в объект Bitmap методом LoadFromFile загружается изображение из выбранного пользователем файла. Затем оператор 
Image1-> Picture -> Assign(Bitmap);
присваивает значение графического объекта Bitmap свойству Picture компонента Image1. Изображение тем самым делается видимым пользователю.
В случае необходимости переписать в Bitmap отредактированое пользователем в Image1, это можно сделать оператором (процедура MSaveClick):
Bitmap -> Assign(Image1->Picture);
Если же надо восстановить в Image1 прежнее изображение, испорченное по каким-то причинам, то это можно сделать оператором (процедура MRestoreClick):
Image1-> Picture ->Assign(Bitmap);
Таким образом, методом Assign можно копировать изображение из одного однотипного графического объекта в другое и обратно.

Доступ к значениям отдельных пикселей изображений
Доступ можно получить с помощью свойства Pixels компонента TCanvas. Это свойство можно использовать как двумерный массив с координатами (x, y), измеряемыми начиная от верхнего левого угла изображения. В листинге 2 демонстрируется, как получить доступ к позиции мыши и значению пикселей, а также показать пользователю перемещение указателя мыши по изображению. Эту информацию можно увидеть в трех полях редактирования.
Листинг 2 Получение значения пикселя при перемещении указателя мыши

void __fastcall TForm1::Image1MouseMove(TObject *Sender, TShiftState Shift, 
int X, int Y) 
{ 
    Edit5->Text = X; 
    Edit6->Text = Y; 
    Edit7->Text = Image1->Canvas->Pixels[X][Y]; 
} 
Текущая координата мыши передается в обработчик события в качестве параметров X и Y. Значение пикселя имеет тип TColor, а его интерпретация зависит от значения свойства PixelFormat. Для изображений в оттенках серого каждый оттенок содержится в младшем байте значения пикселя. Для 24-разрядных цветных изображений младшие три байта представляют RGB-интенсивности для синего, зеленого и красного, соответственно. Значение $00FF0000представляет синий цвет, $0000FF00 – зеленый, а $000000FF –красный. 
Значение пикселя можно также установить с помощью свойства TCanvas->Pixels[][]. Например, после добавления следующей строки в обработчик событий Image1 MouseMove() будет нарисована линия, повторяющая движение указателя мыши.
Image1-> Canvas -> Pixels[X][Y] = clWhite; 
Свойство Canvas -> Pixels[X][Y] очень просто использовать, но работает оно чрезвычайно медленно. Более эффективныйспособ получения доступа к данным изображения – с помощью свойства ScanLine. При использовании свойство ScanLine операции по обработке изображения выполняются в двумерном массиве, а затем необходимо скопировать результат в компонент TBitmap, используя свойство ScanLine. В листинге 3 представлен пример преобразования цветного изображения в полутоновое с использованием свойства ScanLine.

Листинг 3 Преобразование в полутоновое изображение
void__fastcall TForm1::Button6Click(TObject*Sender)
{ 
    int x,y; 
    int R,G,B, result; 
    BYTE* LinePtr; 

    Graphics::TBitmap *Bitmap = new Graphics::TBitmap(); 
    Bitmap->Height=Image1->Picture->Height; 
    Bitmap->Width=Image1->Picture->Width; 
    Bitmap->Assign(Image1->Picture); 

    Bitmap->PixelFormat=pf24bit; 

// Копирование данных изображения в объект Bitmap и их обработка
    for (y=0; y<=Bitmap->Height-1;y++)
    { 
        LinePtr=(BYTE*)Bitmap->ScanLine[y]; 
        for (x=0; x<3*Bitmap->Width; x+=3) 
            { 
            R=LinePtr[x]; G=LinePtr[x+1]; B=LinePtr[x+2]; 
            result=0.3*R+0.59*G+0.11*B; 
            LinePtr[x]=(BYTE)result; 
            LinePtr[x+1]=(BYTE)result; 
            LinePtr[x+2]=(BYTE)result; 
        } 
    } 

// Bitmap->PixelFormat=pf8bit; 

    Image2->Picture->Assign(Bitmap); 
    Image2->Visible=true; 
    delete Bitmap; 
} 
Данные построчно копируются в растровый объект. Переменная LinePtr используется для хранения указателя на первый пиксель линии, возвращаемый свойством ScanLine компонента TCanvas. Каждое значение пикселя должно быть скопировано три раза для трех цветовых компонентов.

5. Контрольные вопросы
1. Какое изображение называется цифровым?
2. В чем сущность методов пространственной и метода частотной обработки изображений?
3. Каково назначение градационного преобразования?
4. Представьте алгоритм преобразования цветного изображения в полутоновое (полутонового в бинарное)?
5. В чем схожесть и отличие логарифмического и степенного преобразований?
6. Представьте алгоритм адаптивной пороговой бинаризации.
7. Приведите примеры практического использования градационных преобразований. 
